{
  "modules": {
    "backend": {
      "modules": [
        "backend",
        "frontend",
        "database"
      ],
      "file_structure": {
        "backend/": "API server files",
        "backend/app/": "Application logic",
        "backend/app/api/": "API endpoints",
        "backend/app/models/": "Database models",
        "backend/app/schemas/": "Data validation schemas",
        "backend/app/core/": "Core application components",
        "backend/tests/": "Unit and integration tests",
        "frontend/": "UI application files",
        "database/": "Schema and migration files"
      },
      "dependencies": [
        "fastapi",
        "uvicorn",
        "pydantic",
        "sqlalchemy",
        "psycopg2-binary",
        "python-dotenv",
        "pytest",
        "requests"
      ],
      "code_files": {
        "src/main.py": "from fastapi import FastAPI\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom app.api import api_router\nfrom app.core.config import settings\n\napp = FastAPI(\n    title=settings.PROJECT_NAME,\n    openapi_url=f\"{settings.API_V1_STR}/openapi.json\"\n)\n\n# Set all CORS enabled origins\nif settings.BACKEND_CORS_ORIGINS:\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],\n        allow_credentials=True,\n        allow_methods=[\"*\"],\n        allow_headers=[\"*\"],\n    )\n\napp.include_router(api_router, prefix=settings.API_V1_STR)\n\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n",
        "package.json": "{\n  \"name\": \"ecommerce_backend\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Backend for ecommerce platform\",\n  \"main\": \"src/main.py\",\n  \"scripts\": {\n    \"start\": \"uvicorn src.main:app --reload\",\n    \"test\": \"pytest\"\n  },\n  \"dependencies\": {\n    \"fastapi\": \"^0.100.0\",\n    \"uvicorn\": \"^0.23.0\",\n    \"pydantic\": \"^2.0.0\",\n    \"sqlalchemy\": \"^2.0.0\",\n    \"psycopg2-binary\": \"^2.9.0\",\n    \"python-dotenv\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"pytest\": \"^7.0.0\",\n    \"requests\": \"^2.0.0\"\n  },\n  \"author\": \"Your Name\",\n  \"license\": \"MIT\"\n}",
        "backend/app/api/__init__.py": "from fastapi import APIRouter\n\nfrom .endpoints import items, users\n\napi_router = APIRouter()\napi_router.include_router(items.router, prefix=\"/items\", tags=[\"items\"])\napi_router.include_router(users.router, prefix=\"/users\", tags=[\"users\"])\n",
        "backend/app/api/endpoints/items.py": "from typing import Any, List\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\nfrom app import crud, models, schemas\nfrom app.api import deps\n\nrouter = APIRouter()\n\n\n@router.get(\"/\", response_model=List[schemas.Item])\ndef read_items(\n    db: Session = Depends(deps.get_db),\n    skip: int = 0,\n    limit: int = 100,\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Retrieve items.\n    \"\"\"\n    if crud.user.is_superuser(current_user):\n        items = crud.item.get_multi(db, skip=skip, limit=limit)\n    else:\n        items = crud.item.get_multi_by_owner(\n            db=db, owner_id=current_user.id, skip=skip, limit=limit\n        )\n    return items\n\n\n@router.post(\"/\", response_model=schemas.Item)\ndef create_item(\n    *, \n    db: Session = Depends(deps.get_db),\n    item_in: schemas.ItemCreate,\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Create new item.\n    \"\"\"\n    item = crud.item.create(db=db, obj_in=item_in, owner_id=current_user.id)\n    return item\n\n\n@router.put(\"/{id}\", response_model=schemas.Item)\ndef update_item(\n    *, \n    db: Session = Depends(deps.get_db),\n    id: int,\n    item_in: schemas.ItemUpdate,\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Update an item.\n    \"\"\"\n    item = crud.item.get(db=db, id=id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not crud.user.is_superuser(current_user) and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    item = crud.item.update(db=db, db_obj=item, obj_in=item_in)\n    return item\n\n\n@router.get(\"/{id}\", response_model=schemas.Item)\ndef read_item(\n    *, \n    db: Session = Depends(deps.get_db),\n    id: int,\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Get item by ID.\n    \"\"\"\n    item = crud.item.get(db=db, id=id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not crud.user.is_superuser(current_user) and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    return item\n\n\n@router.delete(\"/{id}\", response_model=schemas.Item)\ndef delete_item(\n    *, \n    db: Session = Depends(deps.get_db),\n    id: int,\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Delete an item.\n    \"\"\"\n    item = crud.item.get(db=db, id=id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    if not crud.user.is_superuser(current_user) and (item.owner_id != current_user.id):\n        raise HTTPException(status_code=400, detail=\"Not enough permissions\")\n    item = crud.item.remove(db=db, id=id)\n    return item",
        "backend/app/api/endpoints/users.py": "from typing import Any, List\n\nfrom fastapi import APIRouter, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\nfrom app import crud, models, schemas\nfrom app.api import deps\nfrom app.core.config import settings\n\nrouter = APIRouter()\n\n\n@router.post(\"/open\", response_model=schemas.User)\ndef create_user_open(\n    *, \n    db: Session = Depends(deps.get_db),\n    user_in: schemas.UserCreate,\n) -> Any:\n    \"\"\"\n    Create new user without the need to be logged in.\n    \"\"\"\n    if not settings.USERS_OPEN_REGISTRATION:\n        raise HTTPException(\n            status_code=403, detail=\"Open user registration is forbidden on this server\"\n        )\n    user = crud.user.get_by_email(db, email=user_in.email)\n    if user:\n        raise HTTPException(\n            status_code=400, detail=\"The user with this username already exists in the system.\"\n        )\n    user = crud.user.create(db, obj_in=user_in)\n    return user\n\n\n@router.get(\"/\", response_model=List[schemas.User])\ndef read_users(\n    db: Session = Depends(deps.get_db),\n    skip: int = 0,\n    limit: int = 100,\n    current_user: models.User = Depends(deps.get_current_active_superuser),\n) -> Any:\n    \"\"\"\n    Retrieve users.\n    \"\"\"\n    users = crud.user.get_multi(db, skip=skip, limit=limit)\n    return users\n\n\n@router.get(\"/me\", response_model=schemas.User)\ndef read_user_me(\n    db: Session = Depends(deps.get_db),\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Get current user.\n    \"\"\"\n    return current_user\n\n\n@router.patch(\"/me\", response_model=schemas.User)\ndef update_user_me(\n    *, \n    db: Session = Depends(deps.get_db),\n    password: str = None,\n    full_name: str = None,\n    email: str = None,\n    current_user: models.User = Depends(deps.get_current_active_user),\n) -> Any:\n    \"\"\"\n    Update own user.\n    \"\"\"\n    current_user_data = jsonable_encoder(current_user)\n    user_in = schemas.UserUpdate(**current_user_data)\n    if password is not None:\n        user_in.password = password\n    if full_name is not None:\n        user_in.full_name = full_name\n    if email is not None:\n        user_in.email = email\n    user = crud.user.update(db, db_obj=current_user, obj_in=user_in)\n    return user\n\n\n@router.get(\"/{user_id}\", response_model=schemas.User)\ndef read_user(\n    user_id: int,\n    db: Session = Depends(deps.get_db),\n    current_user: models.User = Depends(deps.get_current_active_superuser),\n) -> Any:\n    \"\"\"\n    Get a specific user by id.\n    \"\"\"\n    user = crud.user.get(db, id=user_id)\n    if not user:\n        raise HTTPException(\n            status_code=404, detail=\"The user with this username does not exist in the system\"\n        )\n    return user\n\n\n@router.put(\"/{user_id}\", response_model=schemas.User)\ndef update_user(\n    *, \n    db: Session = Depends(deps.get_db),\n    user_id: int,\n    user_in: schemas.UserUpdate,\n    current_user: models.User = Depends(deps.get_current_active_superuser),\n) -> Any:\n    \"\"\"\n    Update a user.\n    \"\"\"\n    user = crud.user.get(db, id=user_id)\n    if not user:\n        raise HTTPException(\n            status_code=404, detail=\"The user with this username does not exist in the system\"\n        )\n    user = crud.user.update(db, db_obj=user, obj_in=user_in)\n    return user",
        "backend/app/core/config.py": "import os\n\nfrom typing import List\n\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nPROJECT_NAME = os.getenv(\"PROJECT_NAME\", \"Ecommerce Platform\")\n\nAPI_V1_STR = \"/api/v1\"\n\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"postgresql://user:password@localhost:5432/dbname\")\n\nBACKEND_CORS_ORIGINS = os.getenv(\n    \"BACKEND_CORS_ORIGINS\",\n    \"http://localhost,http://localhost:4200,http://localhost:3000\",\n)\n\nBACKEND_CORS_ORIGINS = BACKEND_CORS_ORIGINS.split(\",\")\n\nUSERS_OPEN_REGISTRATION = os.getenv(\"USERS_OPEN_REGISTRATION\", \"True\") == \"True\"\n\nSECRET_KEY = os.getenv(\"SECRET_KEY\", \"YOUR_SECRET_KEY\")\n\nALGORITHM = \"HS256\"\n\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n",
        "backend/app/core/security.py": "from datetime import datetime, timedelta\nfrom typing import Any, Union\n\nfrom jose import jwt\nfrom passlib.context import CryptContext\n\nfrom app.core.config import ALGORITHM, SECRET_KEY\n\npassword_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n\ndef create_access_token(\n    subject: Union[str, Any], expires_delta: timedelta = None\n) -> str:\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=30)\n    to_encode = {\"exp\": expire, \"sub\": str(subject)}\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return password_context.verify(plain_password, hashed_password)\n\n\n\ndef get_password_hash(password: str) -> str:\n    return password_context.hash(password)\n",
        "backend/app/db/base.py": "from app.models.item import Item\nfrom app.models.user import User\n\n# Import all the models, so that Base has them before being\n# imported into Alembic",
        "backend/app/db/base_class.py": "from typing import Any\n\nfrom sqlalchemy.ext.declarative import as_declarative, declared_attr\n\n@as_declarative()\nclass Base:\n    \"\"\"Base class which provides automated table name\n    and surrogate primary key column.\n\n    \"\"\"\n\n    @declared_attr\n    def __tablename__(cls) -> str:\n        return cls.__name__.lower()\n\n    id: Any",
        "backend/app/db/session.py": "from sqlalchemy import create_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom app.core.config import DATABASE_URL\n\nengine = create_engine(DATABASE_URL, pool_pre_ping=True)\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)",
        "backend/app/models/item.py": "from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import relationship\n\nfrom app.db.base_class import Base\n\n\nclass Item(Base):\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, index=True)\n    description = Column(String, index=True)\n    owner_id = Column(Integer, ForeignKey(\"user.id\"))\n    owner = relationship(\"User\", back_populates=\"items\")",
        "backend/app/models/user.py": "from typing import TYPE_CHECKING\n\nfrom sqlalchemy import Boolean, Column, Integer, String\nfrom sqlalchemy.orm import relationship\n\nfrom app.db.base_class import Base\n\nif TYPE_CHECKING:\n    from .item import Item  # noqa: F401\n\n\nclass User(Base):\n    id = Column(Integer, primary_key=True, index=True)\n    full_name = Column(String, index=True)\n    email = Column(String, unique=True, index=True, nullable=False)\n    hashed_password = Column(String, nullable=False)\n    is_active = Column(Boolean(), default=True)\n    is_superuser = Column(Boolean(), default=False)\n    items = relationship(\"Item\", back_populates=\"owner\")",
        "backend/app/schemas/__init__.py": "from .item import Item, ItemCreate, ItemUpdate\nfrom .msg import Msg\nfrom .token import Token, TokenPayload\nfrom .user import User, UserCreate, UserInDB, UserUpdate",
        "backend/app/schemas/item.py": "from typing import Optional\n\nfrom pydantic import BaseModel\n\n\n# Shared properties\nclass ItemBase(BaseModel):\n    title: Optional[str] = None\n    description: Optional[str] = None\n\n\n# Properties to receive on item creation\nclass ItemCreate(ItemBase):\n    title: str\n\n\n# Properties to receive on item update\nclass ItemUpdate(ItemBase):\n    pass\n\n\n# Properties shared by models stored in DB\nclass ItemInDBBase(ItemBase):\n    id: int\n    title: str\n    owner_id: int\n\n    class Config:\n        orm_mode = True\n\n\n# Properties to return to client\nclass Item(ItemInDBBase):\n    pass\n\n\n# Properties properties stored in DB\nclass ItemInDB(ItemInDBBase):\n    pass",
        "backend/app/schemas/msg.py": "from pydantic import BaseModel\n\n\nclass Msg(BaseModel):\n    msg: str",
        "backend/app/schemas/token.py": "from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass TokenBase(BaseModel):\n    access_token: str\n    token_type: str\n\n\nclass Token(TokenBase):\n    pass\n\n\nclass TokenPayload(BaseModel):\n    sub: Optional[str] = None",
        "backend/app/schemas/user.py": "from typing import Optional\n\nfrom pydantic import BaseModel, EmailStr\n\n\n# Shared properties\nclass UserBase(BaseModel):\n    email: Optional[EmailStr] = None\n    full_name: Optional[str] = None\n\n\n# Properties to receive on user creation\nclass UserCreate(UserBase):\n    email: EmailStr\n    password: str\n\n\n# Properties to receive on user update\nclass UserUpdate(UserBase):\n    password: Optional[str] = None\n\n\n# Properties shared by models stored in DB\nclass UserInDBBase(UserBase):\n    id: int\n    email: EmailStr\n    full_name: Optional[str] = None\n    is_active: bool = True\n    is_superuser: bool = False\n\n    class Config:\n        orm_mode = True\n\n\n# Properties to return to client\nclass User(UserInDBBase):\n    pass\n\n\n# Properties properties stored in DB\nclass UserInDB(UserInDBBase):\n    hashed_password: str"
      }
    },
    "frontend": {
      "modules": [
        "frontend"
      ],
      "file_structure": {
        "frontend/": "React UI application files",
        "frontend/src/": "Source code directory",
        "frontend/src/components/": "React components",
        "frontend/src/pages/": "Application pages",
        "frontend/src/App.js": "Main application component",
        "frontend/src/index.js": "Entry point",
        "frontend/public/": "Public assets",
        "frontend/public/index.html": "HTML entry point",
        "frontend/package.json": "Project dependencies and scripts",
        "frontend/.env": "Environment variables"
      },
      "dependencies": [
        "react",
        "react-dom",
        "react-router-dom",
        "axios"
      ],
      "code_files": {
        "frontend/package.json": "{\n  \"name\": \"ecommerce-frontend\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"dependencies\": {\n    \"@testing-library/jest-dom\": \"^5.17.0\",\n    \"@testing-library/react\": \"^13.4.0\",\n    \"@testing-library/user-event\": \"^13.5.0\",\n    \"axios\": \"^1.6.7\",\n    \"react\": \"^18.2.0\",\n    \"react-dom\": \"^18.2.0\",\n    \"react-router-dom\": \"^6.22.1\",\n    \"react-scripts\": \"5.0.1\",\n    \"web-vitals\": \"^2.1.4\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"eslintConfig\": {\n    \"extends\": [\n      \"react-app\",\n      \"react-app/jest\"\n    ]\n  },\n  \"browserslist\": {\n    \"production\": [\n      \">0.2%\",\n      \"not dead\",\n      \"not op_mini all\"\n    ],\n    \"development\": [\n      \"last 1 chrome version\",\n      \"last 1 firefox version\",\n      \"last 1 safari version\"\n    ]\n  }\n}",
        "frontend/src/index.js": "import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { BrowserRouter } from 'react-router-dom';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();",
        "frontend/src/App.js": "import React from 'react';\nimport { Routes, Route } from 'react-router-dom';\nimport HomePage from './pages/HomePage';\nimport ProductPage from './pages/ProductPage';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Routes>\n        <Route path=\"/\" element={<HomePage />} />\n        <Route path=\"/product/:id\" element={<ProductPage />} />\n      </Routes>\n    </div>\n  );\n}\n\nexport default App;",
        "frontend/src/pages/HomePage.js": "import React from 'react';\n\nfunction HomePage() {\n  return (\n    <div>\n      <h1>Welcome to the Ecommerce Platform</h1>\n      <p>Browse our amazing products!</p>\n    </div>\n  );\n}\n\nexport default HomePage;",
        "frontend/src/pages/ProductPage.js": "import React, { useState, useEffect } from 'react';\nimport { useParams } from 'react-router-dom';\nimport axios from 'axios';\n\nfunction ProductPage() {\n  const { id } = useParams();\n  const [product, setProduct] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchProduct = async () => {\n      try {\n        const response = await axios.get(`/api/products/${id}`); // Replace with your actual API endpoint\n        setProduct(response.data);\n        setLoading(false);\n      } catch (err) {\n        setError(err);\n        setLoading(false);\n      }\n    };\n\n    fetchProduct();\n  }, [id]);\n\n  if (loading) {\n    return <p>Loading...</p>;\n  }\n\n  if (error) {\n    return <p>Error: {error.message}</p>;\n  }\n\n  if (!product) {\n    return <p>Product not found</p>;\n  }\n\n  return (\n    <div>\n      <h1>{product.name}</h1>\n      <p>{product.description}</p>\n      <p>Price: ${product.price}</p>\n    </div>\n  );\n}\n\nexport default ProductPage;",
        "frontend/public/index.html": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <meta name=\"theme-color\" content=\"#000000\" />\n    <meta\n      name=\"description\"\n      content=\"Web site created using create-react-app\"\n    />\n    <link rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" />\n    <!--\n      manifest.json provides metadata used when your web app is installed on a\n      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/\n    -->\n    <link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" />\n    <!--\n      Notice the use of %PUBLIC_URL% in the tags above.\n      It will be replaced with the URL of the `public` folder during the build.\n      Only files inside the `public` folder can be referenced from the HTML.\n\n      Unlike \"/favicon.ico\" or \"favicon.ico\", \"%PUBLIC_URL%/favicon.ico\" will\n      work correctly both with client-side routing and a non-root public URL.\n      Learn how to configure a non-root public URL by running `npm run build`.\n    -->\n    <title>Ecommerce Platform</title>\n  </head>\n  <body>\n    <noscript>You need to enable JavaScript to run this app.</noscript>\n    <div id=\"root\"></div>\n    <!--\n      This HTML file is a template.\n      If you open it directly in the browser, you will see an empty page.\n\n      You can add webfonts, meta tags, or analytics to this file.\n      The build step will place the bundled scripts into the <body> tag.\n\n      To begin the development, run `npm start` or `yarn start`.\n    -->\n  </body>\n</html>",
        "frontend/.env": "REACT_APP_API_BASE_URL=http://localhost:8000"
      }
    },
    "database": {
      "modules": [
        "backend",
        "frontend",
        "database"
      ],
      "file_structure": {
        "backend/": "API server files",
        "frontend/": "UI application files",
        "database/": "Schema and migration files"
      },
      "dependencies": [
        "fastapi",
        "uvicorn",
        "psycopg2-binary",
        "alembic",
        "SQLAlchemy"
      ],
      "code_files": {
        "src/main.py": "from fastapi import FastAPI\nfrom database import database, models\nfrom database.database import engine\n\nmodels.Base.metadata.create_all(bind=engine)\n\napp = FastAPI()\n\n@app.on_event(\"startup\")\nasync def startup():\n    await database.connect()\n\n\n@app.on_event(\"shutdown\")\nasync def shutdown():\n    await database.disconnect()\n\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Hello World\"}\n",
        "package.json": "{\n  \"name\": \"ecommerce_platform\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Ecommerce platform with FastAPI, React, and PostgreSQL\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"start\": \"node index.js\",\n    \"dev\": \"nodemon index.js\"\n  },\n  \"dependencies\": {\n    \"react\": \"^18.0.0\",\n    \"react-dom\": \"^18.0.0\"\n  },\n  \"devDependencies\": {\n    \"nodemon\": \"^2.0.15\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}",
        "database/database.py": "from sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\n\nDATABASE_URL = \"postgresql://user:password@postgresserver/db\"\n\nengine = create_engine(DATABASE_URL)\n\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nBase = declarative_base()\n\n# Dependency\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n",
        "database/models.py": "from sqlalchemy import Boolean, Column, Integer, String\nfrom sqlalchemy.orm import relationship\n\nfrom .database import Base\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, index=True)\n    description = Column(String, index=True)\n    owner_id = Column(Integer)\n",
        "database/alembic.ini": "[alembic]\n# path to migration scripts\nscript_location = database/alembic\n\n# template used to generate migration files\n# file_template = %%(rev)s_%%(slug)s\n\n# set to true to use environment context file\n# this will cause the environment to be loaded\n# and the env.py script to be invoked.  See the\n# documentation for more details.\nprepend_sys_path = .\n\nsqlalchemy.url = postgresql://user:password@postgresserver/db\n",
        "database/alembic/env.py": "from logging.config import fileConfig\n\nfrom sqlalchemy import create_engine\n\nfrom alembic import context\n\n# this is the Alembic Config object, which provides\n# access to the values within the .ini file in use.\nconfig = context.config\n\n# Interpret the config file for Python logging.\n# This line sets up loggers basically.\nfileConfig(config.config_file_name)\n\n# add your model's MetaData object here\n# for 'autogenerate' support\n# from myapp import mymodel\n# target_metadata = mymodel.Base.metadata\nfrom database.models import Base\ntarget_metadata = Base.metadata\n\n# other values from the config, defined by the needs of env.py,\n# can be acquired: \n# my_important_option = config.get_main_option(\"my_important_option\")\n# ... etc.\n\ndef run_migrations_offline():\n    \"\"\"Run migrations in 'offline' mode.\n\n    This configures the context with just a URL\n    and not an Engine, though an Engine is acceptable\n    here as well.\n\n    By skipping the Engine creation we don't even need a DBAPI\n    to be available.\n\n    Calls to context.execute() here emit the given string to the\n    script output.\n\n    \"\"\"\n    url = config.get_main_option(\"sqlalchemy.url\")\n    context.configure(\n        url=url,\n        target_metadata=target_metadata,\n        literal_binds=True,\n        dialect_opts={\"paramstyle\": \"named\"},\n    )\n\n    with context.begin_transaction():\n        context.run_migrations()\n\n\ndef run_migrations_online():\n    \"\"\"Run migrations in 'online' mode.\n\n    In this scenario we need to create an Engine\n    and associate a connection with the context.\n\n    \"\"\"\n    connectable = create_engine(\n        config.get_main_option(\"sqlalchemy.url\")\n    )\n\n    with connectable.connect() as connection:\n        context.configure(\n            connection=connection,\n            target_metadata=target_metadata\n        )\n\n        with context.begin_transaction():\n            context.run_migrations()\n\n\nif context.is_offline_mode():\n    run_migrations_offline()\nelse:\n    run_migrations_online()\n"
      }
    }
  },
  "file_structure": {},
  "dependencies": [
    "pydantic",
    "python-dotenv",
    "axios",
    "react-dom",
    "sqlalchemy",
    "psycopg2-binary",
    "uvicorn",
    "react-router-dom",
    "SQLAlchemy",
    "fastapi",
    "alembic",
    "requests",
    "react",
    "pytest"
  ],
  "status": "completed"
}